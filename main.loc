module test-root (test)

import tmp-root-py
import tmp-test

test :: (Int, Int) -> Bool
test =
  ( passed
  . printResult
  . testGroup "testIntegral" testIntegral
  . testGroup "testNumeric" testNumeric
  . testGroup "testSequenceBased" testSequenceBased
  . testGroup "testSequence" testSequence
  -- . testGroup "Bifunctor" testBifunctor
  . testGroup "Functor" testFunctor
  . testGroup "Fold" testFold
  -- . testGroup "Maybe" testMaybe
  . testGroup "Combinators" testCombinators
  -- . testGroup "Tuples" testTuples
  . testGroup "Bools" testBools
  . testGroup "Comparisons" testComparisons
  )

testCombinators :: (Int, Int) -> (Int, Int)
testCombinators =  
  ( testEqual "id" (id 1) 1
  . testEqual "seq" (seq 1 2) 2
  . testEqual "const" (const 1 2) 1
  . testEqual "flip" ((flip const) 1 2) (seq 1 2)
  . testEqual "starling 1" (starling const (const 42) (const 49) 99) 42
  . testEqual "starling 2" (starling const (seq 42) (const 49) 99) 99
  )

-- testTuples :: (Int, Int) -> (Int, Int)
-- testTuples =
--   ( testEqual "fst and snd" (starling const fst snd (1,2)) 1
--   . testEqual "toFst" (toFst snd (1,2)) (2,(1,2))
--   . testEqual "toSnd" (toSnd fst (1,2)) ((1,2),1)
--   . testEqual "fst3, snd3, thr3" ((\t -> (snd3 t, thr3 t, fst3 t)) (3,1,2)) (1,2,3)
--   . testEqual "curry" ((curry fst) 1 2) 1
--   . testEqual "curry3" ((curry3 fst3) 1 2 3) 1
--   . testEqual "uncurry" ((uncurry const) (1,2)) 1
--   )

testBools :: (Int, Int) -> (Int, Int)
testBools =
  ( testEqual "not True" (not True) False
  . testEqual "not False" (not False) True
  . testEqual "and True True" (and True True) True
  . testEqual "and True False" (and True  False) False
  . testEqual "or True  True"  (or True  True)  True
  . testEqual "or True  False" (or True  False) True
  . testEqual "or False True"  (or False True)  True
  . testEqual "or False False" (or False False) False
  . testEqual "xor True  True"  (xor True  True)  False
  . testEqual "xor True  False" (xor True  False) True
  . testEqual "xor False True"  (xor False True)  True
  . testEqual "xor False False" (xor False False) False
  . testEqual "nand True  True"  (nand True  True)  False
  . testEqual "nand True  False" (nand True  False) True
  . testEqual "nand False True"  (nand False True)  True
  . testEqual "nand False False" (nand False False) True
  )

testComparisons :: (Int, Int) -> (Int, Int)
testComparisons =
  ( testEqual "le 1 2" (le 1 2) True
  . testEqual "le 1 1" (le 1 1) True
  . testEqual "le 2 1" (le 2 1) False
  . testEqual "lt 1 2" (lt 1 2) True
  . testEqual "lt 1 1" (lt 1 1) False
  . testEqual "lt 2 1" (lt 2 1) False
  . testEqual "ge 1 2" (ge 1 2) False
  . testEqual "ge 1 1" (ge 1 1) True
  . testEqual "ge 2 1" (ge 2 1) True
  . testEqual "gt 1 2" (gt 1 2) False
  . testEqual "gt 1 1" (gt 1 1) False
  . testEqual "gt 2 1" (gt 2 1) True
  . testEqual "ne 1 2" (ne 1 2) True
  . testEqual "ne 1 1" (ne 1 1) False
  . testEqual "ne 2 1" (ne 2 1) True
  . testEqual "lesser 1 2" (lesser 1 2) 1
  . testEqual "greater 1 2" (greater 1 2) 2
  )

-- testMaybe :: (Int, Int) -> (Int, Int)
-- testMaybe =
--   ( testEqual "maybeToList and just" (maybeToList (just 1)) [1]
--   . testEqual "maybeToList 1" (maybeToList (just 1)) [1]
--   -- . testEqual "listToMaybe" (listToMaybe [1,2]) (just 1)
--   . testEqual "just and fromJust" (fromJust (just 1)) 1
--   . testEqual "catMaybes" (catMaybes [just 1, just 2, nothing]) [1,2]
--   )
--
-- catMaybes a :: [Maybe a] -> [a]
-- catMaybes = map fromOptional . filter isJust
--
-- mapMaybes a :: (a -> Maybe b) -> [a] -> [b]
-- mapMaybes f = filter isJust . map f
--
-- isJust a :: Maybe a -> Bool
-- isJust x = not (isNothing x)
--
-- fromMaybe a :: a -> Maybe a -> a
-- fromMaybe b x = ifelse (isNothing x) b (fromJust x)
--
-- maybe a b :: b -> (a -> b) -> Maybe a -> b
-- maybe b f x = ifelse (isNothing x) b (f (fromJust x))
--
-- fromMaybe a :: a -> Maybe a -> a
-- fromMaybe default x = ifelse (isNothing x) default x


testFold :: (Int, Int) -> (Int, Int)
testFold =
  ( testEqual "length" (fold (\b a -> add 1 b) 0 [1,2,3]) 3
  . testEqual "length" (length [1,2,3]) 3
  )

testSequence :: (Int, Int) -> (Int, Int)
testSequence =
  ( testEqual "at" (at 0 [2,3,4]) 2
  . testEqual "slice 0 0" (slice 0 0 [1,2,3]) []
  . testEqual "slice 0 1" (slice 0 1 [1,2,3]) [1]
  . testEqual "slice 1 0" (slice 1 0 [1,2,3]) []    -- this doesn't reverse
  . testEqual "slice 1 3" (slice 1 3 [1,2,3]) [2,3]
  . testEqual "slice 1 4" (slice 1 4 [1,2,3]) [2,3] -- length may not equal j - i
  . testEqual "slice 3 4" (slice 3 4 [1,2,3]) []
  )

testSequenceBased :: (Int, Int) -> (Int, Int)
testSequenceBased =
  ( testEqual "head [1]" (head [1]) 1
  -- . testEqual "init []" (init []) []
  . testEqual "init [1]" (init [1]) []
  . testEqual "init [1,2]" (init [1,2]) [1]
  . testEqual "init [1,2,3]" (init [1,2,3]) [1,2]
  . testEqual "last [1]" (last [1]) 1
  . testEqual "last [1,2]" (last [1,2]) 2
  . testEqual "tail [1,2,3]" (tail [1,2,3]) [2,3]
  . testEqual "tail [1,2]" (tail [1,2]) [2]
  . testEqual "tail [1]" (tail [1]) []
  -- . testEqual "tail []" (tail []) []
  -- . testEqual "take 0 []" (take 0 []) []
  -- . testEqual "take 1 []" (take 1 []) []
  . testEqual "take 0 [1,2,3]" (take 0 [1,2,3]) []
  . testEqual "take 1 [1,2,3]" (take 1 [1,2,3]) [1]
  . testEqual "take 2 [1,2,3]" (take 2 [1,2,3]) [1,2]
  . testEqual "take 3 [1,2,3]" (take 3 [1,2,3]) [1,2,3]
  . testEqual "take 4 [1,2,3]" (take 4 [1,2,3]) [1,2,3]
  . testEqual "drop 0 [1,2,3]" (drop 0 [1,2,3]) [1,2,3]
  . testEqual "drop 1 [1,2,3]" (drop 1 [1,2,3]) [2,3]
  . testEqual "drop 2 [1,2,3]" (drop 2 [1,2,3]) [3]
  . testEqual "drop 3 [1,2,3]" (drop 3 [1,2,3]) []
  . testEqual "drop 4 [1,2,3]" (drop 4 [1,2,3]) []
  -- . testEqual "flatten [[1],[3,4]]" (flatten [[1],[3,4]]) [1,3,4]
  )

testFunctor :: (Int, Int) -> (Int, Int)
testFunctor =
  ( testEqual "map" (map (add 1) [1,2,3]) [2,3,4]
  )

-- testBifunctor :: (Int, Int) -> (Int, Int)
-- testBifunctor =
--   ( testEqual "bimap tuple" (bimap (add 1) (add 2) (1,2)) (2,4)
--   . testEqual "bimap onA" (onA (add 10) (1,2)) (11,2)
--   . testEqual "bimap onB" (onB (add 10) (1,2)) (1,12)
--   )

testIntegral :: (Int, Int) -> (Int, Int)
testIntegral =
  ( testEqual "add" (add 1 2) 3
  . testEqual "sub" (sub 2 1) 1
  )

testNumeric :: (Real, Real) -> (Real, Real)
testNumeric =
  ( testEqual "mul" (mul 3.0 2.0) 6.0
  . testEqual "div" (div 6.0 2.0) 3.0
  )

-- instance Packable [a] (Maybe a) where
--     pack x = ifelse (isNothing x) [] [x]
--     unpack xs = ifelse (eq (length xs) 0) [] (head xs)
--
-- nothing a :: Maybe a
-- isNothing a :: Maybe a -> Bool
--
-- catMaybes a :: [Maybe a] -> [a]
-- catMaybes = map fromOptional . filter isJust
--
-- mapMaybes a :: (a -> Maybe b) -> [a] -> [b]
-- mapMaybes f = filter isJust . map f
--
-- isJust a :: Maybe a -> Bool
-- isJust x = not (isNothing x)
--
-- fromMaybe a :: a -> Maybe a -> a
-- fromMaybe b x = ifelse (isNothing x) b (fromJust x)
--
-- maybe a b :: b -> (a -> b) -> Maybe a -> b
-- maybe b f x = ifelse (isNothing x) b (f (fromJust x))
--
-- fromMaybe a :: a -> Maybe a -> a
-- fromMaybe default x = ifelse (isNothing x) default x
