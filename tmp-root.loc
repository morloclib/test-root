module tmp-root (*)

import internal

type Filename = Str

type Cpp => Filename = "std::string"
type Cpp => Unit = "mlc::Unit" -- this is an enum with a single element, NOT `void`, which corresponds to bottom
type Cpp => Real = "double"
type Cpp => Int = "int"
type Cpp => Str = "std::string"
type Cpp => Bool = "bool"
type Cpp => (Map a b) = "std::map<$1,$2>" a b
type Cpp => (List a) = "std::vector<$1>" a
type Cpp => (Tuple2 a b) = "std::tuple<$1,$2>" a b
type Cpp => (Tuple3 a b c) = "std::tuple<$1,$2,$3>" a b c
type Cpp => (Tuple4 a b c d) = "std::tuple<$1,$2,$3,$4>" a b c d
type Cpp => (Tuple5 a b c d e) = "std::tuple<$1,$2,$3,$4,$5>" a b c d e
type Cpp => (Tuple6 a b c d e f) = "std::tuple<$1,$2,$3,$4,$5,$6>" a b c d e f
type Cpp => (Tuple7 a b c d e f g) = "std::tuple<$1,$2,$3,$4,$5,$6,$7>" a b c d e f g
type Cpp => (Tuple8 a b c d e f g h) = "std::tuple<$1,$2,$3,$4,$5,$6,$7,$8>" a b c d e f g h
-- type Cpp => (Maybe a) = "std::optional<$1>" a

type Py => Filename = "str"
type Py => Unit = "None"
type Py => Real = "float"
type Py => Int = "int"
type Py => Str = "str"
type Py => Bool = "bool"
type Py => (Map a b) = "dict[$1,$2]" a b
type Py => (List a) = "list[$1]" a
type Py => (Tuple2 a b) = "tuple[$1,$2]" a b
type Py => (Tuple3 a b c) = "tuple[$1,$2,$3]" a b c
type Py => (Tuple4 a b c d) = "tuple[$1,$2,$3,$4]" a b c d
type Py => (Tuple5 a b c d e) = "tuple[$1,$2,$3,$4,$5]" a b c d e
type Py => (Tuple6 a b c d e f) = "tuple[$1,$2,$3,$4,$5,$6]" a b c d e f
type Py => (Tuple7 a b c d e f g) = "tuple[$1,$2,$3,$4,$5,$6,$7]" a b c d e f g
type Py => (Tuple8 a b c d e f g h) = "tuple[$1,$2,$3,$4,$5,$6,$7,$8]" a b c d e f g h
-- type Py => (Maybe a) = "$1|None" a -- Nothing is "None"

type R => Filename = "character"
type R => Unit = "NULL"
type R => Int = "integer"
type R => Real = "numeric"
type R => Str = "character"
type R => Bool = "logical"
type R => (Map Str b) = "list" Str b
type R => (List a) = "list" a
type R => (Tuple2 a b) = "list" a b
type R => (Tuple3 a b c) = "list" a b c
type R => (Tuple4 a b c d) = "list" a b c d
type R => (Tuple5 a b c d e) = "list" a b c d e
type R => (Tuple6 a b c d e f) = "list" a b c d e f
type R => (Tuple7 a b c d e f g) = "list" a b c d e f g
type R => (Tuple8 a b c d e f g h) = "list" a b c d e f g h
-- type R => (Maybe a) = "$1" a

-- instance Packable [a] (Maybe a) where
--     pack = maybeToList
--     unpack = listToMaybe
--
-- nothing a :: Maybe a
-- just a :: a -> Maybe a
-- fromJust a :: Maybe a -> a -- unsafe, undefined for Nothing
-- isNothing a :: Maybe a -> Bool
--
-- catMaybes a :: [Maybe a] -> [a]
-- catMaybes = map fromMaybe . filter isJust
--
-- mapMaybes a b :: (a -> Maybe b) -> [a] -> [b]
-- mapMaybes f = filter isJust . map f
--
-- isJust a :: Maybe a -> Bool
-- isJust x = not (isNothing x)
--
-- fromMaybe a :: a -> Maybe a -> a
-- fromMaybe b x = ifelse (isNothing x) b (fromJust x)
--
-- maybe a b :: b -> (a -> b) -> Maybe a -> b
-- maybe b f x = ifelse (isNothing x) b (f (fromJust x))
--
-- fromMaybe a :: a -> Maybe a -> a
-- fromMaybe default x = ifelse (isNothing x) default x
--
-- maybeToList a :: Maybe a -> [a]
-- maybeToList x = ifelse (isNothing x) [] [fromJust x]
--
-- listToMaybe a :: [a] -> Maybe a
-- listToMaybe xs = ifelse (eq (length xs) 0) nothing (just (head xs))

class Eq a where
  eq a :: a -> a -> Bool

ifelse a :: Bool -> a -> a -> a 

class Ord a where
  le a :: a -> a -> Bool

lt x y = and (le x y) (not (le y x))
ge x y = le y x
gt x y = and (le y x) (not (le x y))

lesser a :: a -> a -> a
lesser x y = ifelse (lt x y) x y

greater a :: a -> a -> a
greater x y = ifelse (lt x y) y x

ne a :: a -> a -> Bool
ne x y = not (eq x y)

class Addable a where
  add a :: a -> a -> a

class Subtractable a where
  sub a :: a -> a -> a

class Foldable f where
  fold f a b :: (b -> a -> b) -> b -> f a -> b

-- O(n), you should probably provide a constant-time implementation for each type
length f a :: f a -> Int
length = fold (\b a -> add 1 b) 0

class Functor f where
  map f a b :: (a -> b) -> f a -> f b

class Bifunctor f where
  bimap f a a' b b' :: (a -> a') -> (b -> b') -> f a b -> f a' b'
  onA f a a' b :: (a -> a') -> f a b -> f a' b
  onB f a b b' :: (b -> b') -> f a b -> f a b'

instance Bifunctor Tuple2 where
  bimap f g x = (f (fst x), g (snd x))
  onA f x = (f (fst x), snd x)
  onB g x = (fst x, g (snd x))

-- all sequences are Addable, Foldable, Filterable and Functors
-- they additionally have a defined order and are isomorphic to lists
-- unlike functors, they can be split
class Sequence f where
    -- at -1 [1,2,3] == FUCK!!!
    -- at 0  [1,2,3] == 1
    -- at 2  [1,2,3] == 3
    -- at 4  [1,2,3] == FUCK!!!
    at f a :: Int -> f a -> a

    -- slice 0 0 [1,2,3] == []
    -- slice 0 1 [1,2,3] == [1]
    -- slice 1 0 [1,2,3] == []    -- this doesn't reverse
    -- slice 1 3 [1,2,3] == [2,3]
    -- slice 1 4 [1,2,3] == [2,3] -- length may not equal j - i
    -- slice 3 4 [1,2,3] == []
    slice f a :: Int -> Int -> f a -> f a


-- warning: unsafe
-- time: O(1)
head f a :: f a -> a -- [1,2,3] => 1
head xs = at 0 xs

-- time: O(n)
-- init [] == []
-- init [1] == []
-- init [1,2] == [1]
-- init [1,2,3] == [1,2]
init f a :: f a -> f a
init xs = slice 0 (sub (length xs) 1) xs

-- last [] == undefined
-- last [1] == 1
-- last [1,2] == 2
last f a :: f a -> a -- [1,2,3] => 3
last xs = at (sub (length xs) 1) xs

-- tail [1,2,3] == [2,3]
-- tail [1,2] == [2]
-- tail [1] == []
-- tail [] == []
tail f a :: f a -> f a -- [1,2,3] => [2,3]
tail xs = slice 1 (length xs) xs

-- take 0 [] = []
-- take 1 [] = []
-- take 0 [1,2,3] = []
-- take 1 [1,2,3] = [1]
-- take 2 [1,2,3] = [1,2]
-- take 3 [1,2,3] = [1,2,3]
-- take 4 [1,2,3] = [1,2,3]
take f a :: Int -> f a -> f a
take i xs = slice 0 i xs

-- drop 0 [1,2,3] = [1,2,3]
-- drop 1 [1,2,3] = [2,3]
-- drop 2 [1,2,3] = [3]
-- drop 3 [1,2,3] = []
-- drop 4 [1,2,3] = []
drop f a :: Int -> f a -> f a
drop i xs = slice i (length xs) xs


-- {{{ Combintators

id a :: a -> a
id x = x

seq a b :: a -> b -> b
seq x y = y

const a b :: a -> b -> a
const x y = x

flip a b c :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

-- From the "To Mock a Mockingbird" aviary
starling a b c d :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
starling bcd ab ac a = bcd (ab a) (ac a)

-- }}}

-- {{{ Boolenas

and :: Bool -> Bool -> Bool
or :: Bool -> Bool -> Bool
not :: Bool -> Bool

xor :: Bool -> Bool -> Bool
xor x y = and (nand x y) (nand (not x) (not y))

nand :: Bool -> Bool -> Bool
nand x y = not (and x y)

-- }}}

-- {{{ Tuples

fst a b :: (a, b) -> a
snd a b :: (a, b) -> b
fst3 a b c :: (a, b, c) -> a
snd3 a b c :: (a, b, c) -> b
thr3 a b c :: (a, b, c) -> c

curry a b c :: ((a, b) -> c) -> a -> b -> c
curry f x y = f (x, y)

curry3 a b c d :: ((a, b, c) -> d) -> a -> b -> c -> d
curry3 f x y z = f (x, y, z)

uncurry a b c :: (a -> b -> c) -> (a, b) -> c
uncurry f xy = f (fst xy) (snd xy)

uncurry3 a b c d :: (a -> b -> c -> d) -> (a, b, c) -> d
uncurry3 f xyz = f (fst3 xyz) (snd3 xyz) (thr3 xyz)

toSnd a b :: (a -> b) -> a -> (a, b)
toSnd f x = (x, f x)

toFst a b :: (a -> b) -> a -> (b, a)
toFst f x = (f x, x)

-- }}}
