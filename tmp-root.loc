module tmp-root (*)

import internal

type Filename = Str

type Cpp => Filename = "std::string"
type Cpp => Unit = "mlc::Unit" -- this is an enum with a single element, NOT `void`, which corresponds to bottom
type Cpp => Real = "double"
type Cpp => Int = "int"
type Cpp => Str = "std::string"
type Cpp => Bool = "bool"
type Cpp => (Map a b) = "std::map<$1,$2>" a b
type Cpp => (List a) = "std::vector<$1>" a
type Cpp => (Tuple2 a b) = "std::tuple<$1,$2>" a b
type Cpp => (Tuple3 a b c) = "std::tuple<$1,$2,$3>" a b c
type Cpp => (Tuple4 a b c d) = "std::tuple<$1,$2,$3,$4>" a b c d
type Cpp => (Tuple5 a b c d e) = "std::tuple<$1,$2,$3,$4,$5>" a b c d e
type Cpp => (Tuple6 a b c d e f) = "std::tuple<$1,$2,$3,$4,$5,$6>" a b c d e f
type Cpp => (Tuple7 a b c d e f g) = "std::tuple<$1,$2,$3,$4,$5,$6,$7>" a b c d e f g
type Cpp => (Tuple8 a b c d e f g h) = "std::tuple<$1,$2,$3,$4,$5,$6,$7,$8>" a b c d e f g h
type Cpp => (Maybe a) = "std::optional<$1>" a

type Py => Filename = "str"
type Py => Unit = "None"
type Py => Real = "float"
type Py => Int = "int"
type Py => Str = "str"
type Py => Bool = "bool"
type Py => (Map a b) = "dict" a b
type Py => (List a) = "list" a
type Py => (Tuple2 a b) = "tuple" a b
type Py => (Tuple3 a b c) = "tuple" a b c
type Py => (Tuple4 a b c d) = "tuple" a b c d
type Py => (Tuple5 a b c d e) = "tuple" a b c d e
type Py => (Tuple6 a b c d e f) = "tuple" a b c d e f
type Py => (Tuple7 a b c d e f g) = "tuple" a b c d e f g
type Py => (Tuple8 a b c d e f g h) = "tuple" a b c d e f g h
type Py => (Maybe a) = "$1" a -- Nothing is "None"

type R => Filename = "character"
type R => Unit = "NULL"
type R => Int = "integer"
type R => Real = "numeric"
type R => Str = "character"
type R => Bool = "logical"
type R => (Map Str b) = "list" Str b
type R => (List a) = "list" a
type R => (Tuple2 a b) = "list" a b
type R => (Tuple3 a b c) = "list" a b c
type R => (Tuple4 a b c d) = "list" a b c d
type R => (Tuple5 a b c d e) = "list" a b c d e
type R => (Tuple6 a b c d e f) = "list" a b c d e f
type R => (Tuple7 a b c d e f g) = "list" a b c d e f g
type R => (Tuple8 a b c d e f g h) = "list" a b c d e f g h
type R => (Maybe a) = "$1" a -- Nothing is "NULL"

class Eq a where
  eq a :: a -> a -> Bool

ifelse a :: Bool -> a -> a -> a 

class Ord a where
  le a :: a -> a -> Bool

lt x y = and (le x y) (not (le y x))
ge x y = le y x
gt x y = and (le y x) (not (le x y))

lesser a :: a -> a -> a
lesser x y = ifelse (lt x y) x y

greater a :: a -> a -> a
greater x y = ifelse (lt x y) y x

ne a :: a -> a -> Bool
ne x y = not (eq x y)


-- {{{ Combintators

id a :: a -> a
id x = x

seq a b :: a -> b -> b
seq x y = y

const a b :: a -> b -> a
const x y = x

flip a b c :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

-- From the "To Mock a Mockingbird" aviary
starling a b c d :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
starling bcd ab ac a = bcd (ab a) (ac a)

-- }}}

-- {{{ Boolenas

and :: Bool -> Bool -> Bool
or :: Bool -> Bool -> Bool
not :: Bool -> Bool

xor :: Bool -> Bool -> Bool
xor x y = and (nand x y) (nand (not x) (not y))

nand :: Bool -> Bool -> Bool
nand x y = not (and x y)

-- }}}

-- {{{ Tuples

fst a b :: (a, b) -> a
snd a b :: (a, b) -> b
fst3 a b c :: (a, b, c) -> a
snd3 a b c :: (a, b, c) -> b
thr3 a b c :: (a, b, c) -> c

curry a b c :: ((a, b) -> c) -> a -> b -> c
curry f x y = f (x, y)

curry3 a b c d :: ((a, b, c) -> d) -> a -> b -> c -> d
curry3 f x y z = f (x, y, z)

uncurry a b c :: (a -> b -> c) -> (a, b) -> c
uncurry f xy = f (fst xy) (snd xy)

uncurry3 a b c d :: (a -> b -> c -> d) -> (a, b, c) -> d
uncurry3 f xyz = f (fst3 xyz) (snd3 xyz) (thr3 xyz)

toSnd a b :: (a -> b) -> a -> (a, b)
toSnd f x = (x, f x)

toFst a b :: (a -> b) -> a -> (b, a)
toFst f x = (f x, x)

-- }}}
